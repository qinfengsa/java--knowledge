## 数据库设计范式

**数据库设计三大范式**

- 第一范式(1st NF －列都是不可再分)

  数据表中的每一列（每个字段）必须是不可拆分的最小单元，也就是确保每一列的原子性；

- 第二范式(2nd NF－每个表只描述一件事情)

  满足第一范式，并且表中非主键列不存在对主键的部分依赖

- 第三范式(3rd NF－不存在对非主键列的传递依赖)

  满足第二范式，并且表中的列不存在对非主键列的传递依赖

## 事务（ACID）

### 事务 ACID 特性

**原子性（Atomicity）**

事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。不能出现一部分成功，一部分失败

**一致性（Consistency）**

数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对一个数据的读取结果都是相同的。

**隔离性（Isolation）**

多个事务并发访问时，事务之间是隔离的，一个事务不应该影响其它事务运行效果。

**持久性（Durability）**

一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。

### 事务并发带来的问题

**更新丢失**：T1 和 T2 两个事务都对一个数据进行修改，T1 先修改，T2 随后修改，T2 的修改覆盖了 T1 的修改。

**脏读**：T1 修改一个数据，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。

**不可重复读**：T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。

**幻读**：T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。

### 事务的隔离级别

**未提交读（Read Uncommitted）**

事务中的修改，即使没有提交，对其它事务也是可见的。**没有解决并发问题**

**提交读（Read Committed）**

一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。**解决脏读问题**

**可重复读（Repeatable Read）**

保证在同一个事务中多次读取同样数据的结果是一样的。**解决不可重复读问题**

**可串行化（Serializable）**

最高的隔离级别，通过强制事务的串行执行，事务只能一个接着一个地执行，但不能并发执行，需要加锁实现；**解决所有问题**



## 索引

索引是为了加速对表中数据行的检索而创建的一种分散存储的数据结构

**索引的优点：**

* 索引能极大的减少存储引擎需要扫描的数据量
* 索引可以把随机IO变成顺序IO
* 索引可以帮助我们在进行分组、排序等操作时，避免使用临时表

**聚集索引**:  索引的键值逻辑顺序决定了表数据行的物理存储顺序；索引的顺序和表数据行的顺序是一致的

> 聚集索引类似于新华字典中用拼音去查找汉字，拼音检索表于书记顺序都是按照a~z排列的，就像相同的逻辑顺序于物理顺序一样，当你需要查找**a**,**ai**两个读音的字，或是想一次寻找多个**傻(sha)**的同音字时，也许向后翻几页，或紧接着下一行就得到结果了。

**非聚集索引**: 索引的逻辑顺序与磁盘上的物理存储顺序不同 

> 非聚集索引类似在新华字典上通过偏旁部首来查询汉字，检索表也许是按照横、竖、撇来排列的，但是由于正文中是a~z的拼音顺序，所以就类似于逻辑地址于物理地址的不对应。同时适用的情况就在于分组，大数目的不同值，频繁更新的列中，这些情况即不适合聚集索引。

### B+ Tree索引

是大多数 MySQL 存储引擎的默认索引类型

![1566783176916](E:\面试题目\知识总结\img\B+Tree.png)

B+Tree索引的优点

* **更少的查找次数：**平衡树查找操作的时间复杂度和树高 h 相关，O(h)=O(logdN)，其中 d 为每个节点的出度。红黑树的出度为 2，而 B+ Tree 的出度一般都非常大，所以红黑树的树高 h 很明显比 B+ Tree 大非常多，查找的次数也就更多。

* **利用磁盘预读特性**：为了减少磁盘 I/O 操作，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的磁盘旋转时间，速度会非常快。

  操作系统一般将内存和磁盘分割成固定大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点。并且可以利用预读特性，相邻的节点也能够被预先载入。

* 自带排序功能，查询效率更加稳定，所有查询结点都经过相同的IO次数

### Hash索引

哈希索引能以 O(1) 时间进行查找，但是失去了有序性：

- 无法用于排序与分组；
- 只支持精确查找，无法用于部分查找和范围查找。

InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。

## 存储引擎

### InnoDB 

InnoDB 是MySQL 默认的事务型存储引擎，只有在需要它不支持的特性时，才考虑使用其它存储引擎。

实现了四个标准的隔离级别，默认级别是可重复读（REPEATABLE READ）。在可重复读隔离级别下，通过多版本并发控制（MVCC）+ Next-Key Locking 防止幻读。

主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。

内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。

支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。

### MyISAM

不支持事务。

不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入（CONCURRENT INSERT）。

### 区别

- 事务：InnoDB 是事务型的，可以使用 Commit 和 Rollback 语句。
- 并发：MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。
- 外键：InnoDB 支持外键。
- 备份：InnoDB 支持在线热备份。
- 崩溃恢复：MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。
- 其它特性：MyISAM 支持压缩表和空间数据索引。
- 查询：InnoDB 中不保存表的具体行数，也就是说，执行select count(*) from table时，InnoDB要扫描一遍整个表来计算有多少行，但是MyISAM只要简单的读出保存好的行数即可。注意的是，当count(*)语句包含 where条件时，两种表的操作是一样的。





## 性能优化

### 索引优化 



死锁原因



